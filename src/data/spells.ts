import { Spell, LegacySpell } from '@/types/character';

// Use import.meta.env.BASE_URL to get the correct base path (works with GitHub Pages)
const BUNDLED_SPELLS_PATH = `${import.meta.env.BASE_URL}data/spells.json`;

// MS5: Spell database loaded from JSON (generated by scripts/parse-spells.ts)
// This will be populated by loadSpellDatabase()
let spellDatabase: Spell[] = [];
let spellDatabaseLoaded = false;

// Cache configuration (matches perks cache duration)
const SPELL_CACHE_KEY = 'exceed-spells-cache';
const CACHE_DURATION_MS = 7 * 24 * 60 * 60 * 1000; // 7 days

interface SpellDatabaseJSON {
  version: string;
  lastUpdated: number;
  spells: Spell[];
}

interface SpellCache {
  database: SpellDatabaseJSON;
  timestamp: number;
  expiresAt: number;
}

/**
 * Get cached spells from localStorage
 */
function getCachedSpells(): Spell[] | null {
  try {
    const cacheStr = localStorage.getItem(SPELL_CACHE_KEY);
    if (!cacheStr) return null;

    const cache: SpellCache = JSON.parse(cacheStr);

    // Check if cache is expired
    if (Date.now() > cache.expiresAt) {
      localStorage.removeItem(SPELL_CACHE_KEY);
      return null;
    }

    console.log('[SpellLoader] Using cached spells from localStorage');
    return cache.database.spells;
  } catch (error) {
    console.error('[SpellLoader] Error reading cache:', error);
    return null;
  }
}

/**
 * Save spells to cache
 */
function cacheSpells(database: SpellDatabaseJSON): void {
  try {
    const cache: SpellCache = {
      database,
      timestamp: Date.now(),
      expiresAt: Date.now() + CACHE_DURATION_MS,
    };

    localStorage.setItem(SPELL_CACHE_KEY, JSON.stringify(cache));
    console.log('[SpellLoader] Cached spells in localStorage');
  } catch (error) {
    console.error('[SpellLoader] Error caching spells:', error);
  }
}

/**
 * Load the spell database from JSON file with cache fallback
 * Should be called at app startup
 */
export async function loadSpellDatabase(): Promise<void> {
  if (spellDatabaseLoaded) return;

  // Try cache first
  const cached = getCachedSpells();
  if (cached) {
    spellDatabase = cached;
    spellDatabaseLoaded = true;
    return;
  }

  // Load from bundled file
  try {
    console.log('[SpellLoader] Fetching spells from:', BUNDLED_SPELLS_PATH);
    const response = await fetch(BUNDLED_SPELLS_PATH);
    if (!response.ok) {
      throw new Error(`Failed to load spells.json: ${response.status} ${response.statusText}`);
    }
    const data: SpellDatabaseJSON = await response.json();
    spellDatabase = data.spells;
    spellDatabaseLoaded = true;

    // Cache the results
    cacheSpells(data);

    console.log(`[SpellLoader] Loaded ${spellDatabase.length} spells from database`);
  } catch (error) {
    console.error('[SpellLoader] Error loading spell database:', error);
    // Fallback to empty - app can still function with custom spells
    spellDatabase = [];
    spellDatabaseLoaded = true;
  }
}

/**
 * Clear spell cache (for debugging/testing)
 */
export function clearSpellCache(): void {
  localStorage.removeItem(SPELL_CACHE_KEY);
  console.log('[SpellLoader] Cache cleared');
}

/**
 * Get all spells from the database
 */
export function getAllSpells(): Spell[] {
  return spellDatabase;
}

/**
 * Get a spell by name
 */
export function getSpellByName(name: string): Spell | undefined {
  return spellDatabase.find(s => s.name === name);
}

/**
 * Get a spell by ID
 */
export function getSpellById(id: string): Spell | undefined {
  return spellDatabase.find(s => s.id === id);
}

/**
 * Get spells filtered by tier
 */
export function getSpellsByTier(tier: number): Spell[] {
  return spellDatabase.filter(s => s.tier === tier);
}

/**
 * Check if the spell database has been loaded
 */
export function isSpellDatabaseLoaded(): boolean {
  return spellDatabaseLoaded;
}

/**
 * Convert new Spell format to legacy format
 */
function spellToLegacy(spell: Spell): LegacySpell {
  const limitCost = typeof spell.basic.limitCost === 'number'
    ? spell.basic.limitCost
    : 0;

  return {
    tier: spell.tier,
    type: spell.type,
    apCost: spell.apCost,
    attributes: spell.attributes,
    limitCost,
    traits: spell.traits,
    effect: spell.basic.effect || spell.shortDescription,
    distance: spell.basic.distance || '-',
    duration: spell.duration || '-',
    damage: spell.basic.damage,
  };
}

/**
 * Get a legacy spell by name (for backwards compatibility)
 */
export function getLegacySpellByName(name: string): LegacySpell | undefined {
  const spell = getSpellByName(name);
  if (!spell) return undefined;
  return spellToLegacy(spell);
}

// Legacy SPELLS object for backwards compatibility
// Maps spell name to spell data
export const SPELLS: Record<string, LegacySpell> = new Proxy({} as Record<string, LegacySpell>, {
  get(_target, prop: string) {
    return getLegacySpellByName(prop);
  },
  has(_target, prop: string) {
    return getSpellByName(prop) !== undefined;
  },
  ownKeys(_target) {
    return spellDatabase.map(s => s.name);
  },
  getOwnPropertyDescriptor(_target, prop: string) {
    const legacy = getLegacySpellByName(prop);
    if (!legacy) return undefined;
    return {
      enumerable: true,
      configurable: true,
      value: legacy,
    };
  }
});

// Helper to get all spell entries for Object.entries() compatibility
export function getSpellEntries(): [string, LegacySpell][] {
  return spellDatabase.map(spell => [spell.name, spellToLegacy(spell)]);
}

// XP costs for learning spells by tier and type
export const SPELL_XP_COSTS: Record<number, { basic: number; advanced: number }> = {
  0: { basic: 1, advanced: 3 },
  1: { basic: 3, advanced: 5 },
  2: { basic: 5, advanced: 7 },
  3: { basic: 7, advanced: 10 },
  4: { basic: 10, advanced: 15 },
  5: { basic: 15, advanced: 25 }
};

// Spellcraft progression XP requirements (follows attribute pricing)
export const SPELLCRAFT_XP_REQUIREMENTS: Record<number, number> = {
  0: 0,    // Starting level
  1: 5,    // 5 XP to reach level 1
  2: 15,   // +10 XP (total 15)
  3: 30,   // +15 XP (total 30)
  4: 50,   // +20 XP (total 50)
  5: 75    // +25 XP (total 75)
};

// MS5: SPELL_UPGRADES is no longer needed - advanced versions are now in the spell data
// Keeping for backwards compatibility but deprecated
export const SPELL_UPGRADES: Record<string, Partial<LegacySpell>> = {};
